#!/usr/bin/env python
"""
jest runs your jython test or test class

Just a shorthand to ant. Finds the test you want and executes the
correct command in this process's place, or tells you the problem.

There are 2x2 primary cases, and jest knows them:

test.testThing.TestThing
test.testThing.TestThing.testThis
module.test.testThing.TestOtherThing
module.test.testThing.TestOtherThing.testThat

jest TestThing
jest testThat

It does this by building a tagfile (json) of test locations, and
rebuilding that file when needed.

If jest can't find a test, it will rebuild your tag file.
"""

VERSION="0.0.1"
REQ_PYTHON = (2,7,0)
import sys
if sys.version_info < REQ_PYTHON:
    sys.stderr.write("%s requires python %s or later.\n" % (__file__, ".".join([str(x) for x in REQ_PYTHON])))
    sys.exit(1)

TESTTAGFILE = ".jest.tags"

import argparse
import json
import os
import re

def load_tags(filename = TESTTAGFILE):
    if not os.path.exists(filename) or not os.path.isfile(filename):
        return None
    tags = None
    try:
        with open(filename) as infile:
            tags = json.load(infile)
    except ValueError:
        #import logging
        #logging.exception('')
        sys.stderr.write("jest: Your tags file ist kaput. Discarding.\n")
    return tags

def save_tags(tags, filename = TESTTAGFILE):
    with open(filename, 'w') as outfile:
        json.dump(tags, outfile, sort_keys=True, indent=2)

def find_test(test_name, tags):
    if test_name not in tags:
        print("Couldn't find test name. Typo or rebuild tags.")
        sys.exit(1)
    if len(tags[test_name]) > 1:
        print("Found multiple tests:")
        for location in tags[test_name]:
            print("  {0}".format(location))
        sys.exit(1)
    location = tags[test_name][0]
    print("Found test {0}".format(location))
    return location

def run_test(test_name):
    '''replace currently running process with the intended test invocation'''
    # holy shit, this entire block is horrible
    args = ["ant", "testModule", "-Dtest.name={0}".format(test_name)]
    print("Running: %s" % " ".join(args))
    cmd = args[0] # executable to run
    args[0] = "jest test {0}".format(test_name)
    os.execlp(cmd, *args)

reFromClass = re.compile(r"^class (.*?)\s*[\(:]")
reFromDef = re.compile(r"\s+def (.*?)\(")

def crawl(directory):
    '''search for classes and functions, store in ant testModule
    friendly format'''
    tags = {}
    for root, dirs, files in os.walk(directory):
        # save time
        for x in [".svn", ".git", ".hg", "CVS"]:
            if x in dirs:
                dirs.remove(x)

        for f in files:
            fpath = os.path.join(root, f)
            if f.startswith('test'):
                with open(fpath) as fin:
                    lines = [x for x in fin.readlines() if 'def test' in x or 'class ' in x]
                current_class = None
                for line in lines:
                    m1 = reFromClass.search(line)
                    if m1:
                        cls = m1.group(1)
                        if not cls:
                            continue
                        fpath = re.sub("./jython/", "", fpath)
                        fpath = re.sub("/", ".", fpath)
                        fpath = re.sub(".py", "", fpath)
                        path_class = ".".join([fpath, cls])
                        tags.setdefault(cls, []).append(path_class)
                        current_class = path_class
                        continue
                    # occasionally have non-testclass functions around
                    if not current_class:
                        continue
                    m2 = reFromDef.search(line)
                    if m2:
                        func = m2.group(1)
                        path_func = ".".join([current_class, func])
                        tags.setdefault(func, []).append(path_func)
    return tags

def test(test_name, nop=None, *args):
    '''load tags, find test, replace this process with test'''
    tags = load_tags()
    searched = False
    if not tags:
        tags = crawl("./")
        if not tags:
            print("Where are you? Can't find anything here.")
            sys.exit(1)
        save_tags(tags)
    location = find_test(test_name, tags)
    # If we didn't find anything but already searched, don't search
    # again. Otherwise rebuild the tags and try again.
    if not searched and not location:
        tags = crawl("./")
        if not tags:
            print("Where are you? Can't find anything here.")
        location = find_test(test_name, tags)
        save_tags(tags)
    if not nop:
        run_test(location)

def main():
    # are we in plugins?
    project = os.path.split(os.getcwd())[1]
    if project != "plugins":
        print("jest only works for the calhoun plugins project")
        sys.exit(1)

    # create the top-level parser
    parser = argparse.ArgumentParser(description="easily test calhoun python",
                                     version=VERSION)
    parser.add_argument('test_name',
                        action='store',
                        help='filename or function name to test')
    parser.add_argument('-n', '--nop',
                        action='store_true',
                        default=False,
                        help='output test name and exit (do not execute)')
    args = parser.parse_args()
    arguments = vars(args)
    test(**arguments)

if __name__ == '__main__':
    main()
